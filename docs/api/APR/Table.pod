=head1 NAME

APR::Table - Perl API for for manipulating opaque string-content table



=head1 Synopsis

  use APR::Table ();
  
  $table = make($pool, $nelts);
  $table_copy = $table->copy($pool);
  
  $table->clear();
  
  $table->set($key => $val);
  $table->unset($key);
  $table->add($key, $val);
  
  $val = $table->get($key);
  @val = $table->get($key);
  
  $table->merge($key => $val);
  overlap($table_a, $table_b, $flags);
  $new_table = overlay($table_base, $table_overlay, $pool);
  
  $table->do(sub {print "key $_[0], value $_[1]\n"}, @valid_keys);
  
  #Tied Interface
  $value = $table->{$key};
  $table->{$key} = $value;
  $table->{$key} = $value;
  exists $table->{$key};
  
  foreach my $key (keys %{$table}) {
      print "$key = $table->{$key}\n";
  }





=head1 Description

C<APR::Table> allows its users to manipulate opaque string-content
tables.

The table's structure is somewhat similar to the Perl's hash
structure, but allows multiple values for the same key.  An access to
the records stored in the table always requires a key.

The key-value pairs are stored in the order they are added.

The keys are case-insensitive.

However as of the current implementation if more than value for the
same key is requested, the whole table is lineary searched, which is
very inefficient unless the table is very small.

C<APR::Table> provides a L<TIE Interface|/TIE_Interface>.

See I<apr/include/apr_tables.h> in ASF's I<apr> project for low level
details.





=head1 API

C<APR::Table> provides the following functions and/or methods:




=head2 C<add>

Add data to a table, regardless of whether there is another element
with the same key.

  $t->add($key, $val);

=over 4

=item arg1: C<$t> (C<L<APR::Table|docs::2.0::api::APR::Table>>)

The table to add to.

=item arg2: C<$key> (string)

The key to use.

=item arg3: C<$val> (string)

The value to add.

=item ret: no return value

=back

When adding data, this function makes a copy of both the key and the
value.



=head2 C<clear>

Delete all of the elements from a table.

  $t->clear();

=over 4

=item arg1: C<$t> (C<L<APR::Table|docs::2.0::api::APR::Table>>)

The table to clear.

=item ret: no return value

=back





=head2 C<compress>

Eliminate redundant entries in a table by either overwriting or
merging duplicates:

  $t->compress($flags);

=over 4

=item arg1: C<$t> (C<L<APR::Table|docs::2.0::api::APR::Table>>)

The table to compress.

=item arg2: C<$flags> (integer)

  APR::OVERLAP_TABLES_MERGE -- to merge
  APR::OVERLAP_TABLES_SET   -- to overwrite

=item ret: no return value

=back

Converts multi-valued keys in C<$table> to single-valued keys.  This
function takes duplicate table entries and flattens them into a single
entry.  The flattening behavior is controlled by the (mandatory)
C<$flags> argument.

When C<$flags> == C<APR::OVERLAP_TABLES_SET>, each key will be set to
the last value seen for that key.  For example, given key/value pairs
'foo =E<gt> bar' and 'foo =E<gt> baz', 'foo' would have a final value
of 'baz' after compression - the 'bar' value would be lost.

When C<$flags> == C<APR::OVERLAP_TABLES_MERGE>, multiple values for
the same key are flattened into a comma-separated list.  Given
key/value pairs 'foo =E<gt> bar' and 'foo =E<gt> baz', 'foo' would
have a final value of 'bar, baz' after compression.



=head2 C<copy>

Create a new table and copy another table into it.

  $ret = $t->copy($p);

=over 4

=item arg1: C<$t> (C<L<APR::Table|docs::2.0::api::APR::Table>>)

The table to copy.

=item arg2: C<$p> (C<L<APR::Pool|docs::2.0::api::APR::Pool>>)

The pool to allocate the new table out of.

=item ret: C<$ret> (C<L<APR::Table|docs::2.0::api::APR::Table>>)

A copy of the table passed in.

=back





=head2 C<do>

Iterate over all the elements of the table, invoking provided
subroutine for each element.  The subroutine gets passed as argument,
a key-value pair.

  $table->do(sub {...}, @filter);

=over 4

=item arg1: C<$p> (C<L<APR::Table|docs::2.0::api::APR::Table>>)

The table to operate on.

=item arg2: C<$sub> (CODE ref/string)

A subroutine reference or name to be called on each item in the table.
The subroutine can abort the iteration by returning 0 and should
always return 1 otherwise.

=item opt arg3: C<@filter> (ARRAY)

If passed, only keys matching one of the entries in the C<@filter>
will be processed.

=item ret: no return value

=back







=head2 C<get>

Get the value(s) associated with a given key.  After this call, the
data is still in the table.

  $val = $table->get($key);
  @val = $table->get($key);

=over 4

=item arg1: C<$t> (C<L<APR::Table|docs::2.0::api::APR::Table>>)

The table to search for the key.

=item arg2: C<$key> (string)

The key to search for.

=item ret: C<$val> or C<@val>

In the scalar context the first matching value returned. (The oldest
in the table, if there is more than one value.)

In the list context the whole table is traversed and all matching
values are returned. If nothing matches C<undef> is returned.

=back








=head2 C<make>

Make a new table.

  $ret = make($p, $nelts);

=over 4

=item arg1: C<$p> (C<L<APR::Pool|docs::2.0::api::APR::Pool>>)

The pool to allocate the pool out of.

=item arg2: C<$nelts> (integer)

The number of elements in the initial table.

=item ret: C<$ret> (C<L<APR::Table|docs::2.0::api::APR::Table>>)

The new table.

=back

Note: This table can only store text data.





=head2 C<merge>

Add data to a table by merging the value with data that has already
been stored:

  $t->merge($key, $val);

=over 4

=item arg1: C<$t> (C<L<APR::Table|docs::2.0::api::APR::Table>>)

The table to search for the data.

=item arg2: C<$key> (string)

The key to merge data for.

=item arg3: C<$val> (string)

The data to add.

=item ret: no return value

=back

Note: if the key is not found, then this function acts like
C<L<add()|/C_add_>>.



=head2 C<overlap>

For each key/value pair in C<$t_b>, add the data to C<$t_a>. The
definition of C<$flags> explains how C<$flags> define the overlapping
method.

  $t_a->overlap($t_b, $flags);

=over 4

=item arg1: C<$t_a> (C<L<APR::Table|docs::2.0::api::APR::Table>>)

The table to add the data to.

=item arg2: C<$t_b> (C<L<APR::Table|docs::2.0::api::APR::Table>>)

The table to iterate over, adding its data to table C<$t_a>

=item arg3: C<$flags> (integer)

How to add the table to table C<$t_a>.

When C<$flags> == C<APR::OVERLAP_TABLES_SET>, if another element
already exists with the same key, this will over-write the old data.

When C<$flags> == C<APR::OVERLAP_TABLES_MERGE>, the key/value pair
from C<$t_b> is added, regardless of whether there is another element
with the same key in C<$t_a>.

=item ret: no return value

=back

This function is highly optimized, and uses less memory and CPU cycles
than a function that just loops through table C<$t_b> calling other
functions.

Conceptually, C<overlap()> does this:

  apr_array_header_t *barr = apr_table_elts(b);
  apr_table_entry_t *belt = (apr_table_entry_t *)barr-E<gt>elts;
  int i;
  
  for (i = 0; i E<lt> barr-E<gt>nelts; ++i) {
      if (flags & APR_OVERLAP_TABLES_MERGE) {
          apr_table_mergen(a, belt[i].key, belt[i].val);
      }
      else {
          apr_table_setn(a, belt[i].key, belt[i].val);
      }
  }

Except that it is more efficient (less space and cpu-time) especially
when C<$t_b> has many elements.

Notice the assumptions on the keys and values in C<$t_b> -- they must
be in an ancestor of C<$t_a>'s pool.  In practice C<$t_b> and C<$t_a> are
usually from the same pool.


=head2 C<overlay>

Merge two tables into one new table. The resulting table may have more
than one value for the same key.

  $t = $t_base->overlay($t_overlay, $p);

=over 4

=item arg1: C<$t_base> (C<L<APR::Table|docs::2.0::api::APR::Table>>)

The table to add at the end of the new table.

=item arg2: C<$t_overlay> (C<L<APR::Table|docs::2.0::api::APR::Table>>)

The first table to put in the new table.

=item arg3: C<$p> (C<L<APR::Pool|docs::2.0::api::APR::Pool>>)

The pool to use for the new table.

=item ret: C<$t> (C<L<APR::Table|docs::2.0::api::APR::Table>>)

A new table containing all of the data from the two passed in.

=back





=head2 C<set>

Add a key/value pair to a table, if another element already exists
with the same key, this will over-write the old data.

  $t->set($key, $val);

=over 4

=item arg1: C<$t> (C<L<APR::Table|docs::2.0::api::APR::Table>>)

The table to add the data to.

=item arg2: C<$key> (string)

The key to use.

=item arg3: C<$val> (string)

The value to add.

=item ret: no return value

=back

When adding data, this function makes a copy of both the key and the
value.



=head2 C<unset>

Remove data from the table.

  $t->unset($key);

=over 4

=item arg1: C<$t> (C<L<APR::Table|docs::2.0::api::APR::Table>>)

The table to remove data from.

=item arg2: C<$key> (string)

The key of the data being removed.

=item ret: no return value

=back




=head1 TIE Interface

C<APR::Table> also implements a tied interface, so you can work with the
C<$table> object as a hash reference.

The following tied-hash function are supported: FETCH, STORE, DELETE,
CLEAR, EXISTS, FIRSTKEY, NEXTKEY and DESTROY.

remark: C<APR::Table> can hold more than one key-value pair sharing
the same key, so when using a table through the tied interface, the
first entry found with the right key will be used, completely
disregarding possible other entries with the same key.  The only
exception to this is if you iterate over the list with I<each>, then
you can access all key-value pairs that share the same key.

=head2 C<EXISTS>

  $ret = $t->EXISTS($key);

=over 4

=item arg1: C<$t> (C<L<APR::Table|docs::2.0::api::APR::Table>>)

=item arg2: C<$key> (string)

=item ret: C<$ret> (integer)



=back





=head2 C<CLEAR>

  $t->CLEAR();

=over 4

=item arg1: C<$t> (C<L<APR::Table|docs::2.0::api::APR::Table>>)

=item ret: no return value

=back





=head2 C<STORE>

  $t->STORE($key, $value);

=over 4

=item arg1: C<$t> (C<L<APR::Table|docs::2.0::api::APR::Table>>)

=item arg2: C<$key> (string)

=item arg3: C<$value> (string)

=item ret: no return value

=back





=head2 C<DELETE>

  $t->DELETE($key);

=over 4

=item arg1: C<$t> (C<L<APR::Table|docs::2.0::api::APR::Table>>)

=item arg2: C<$key> (string)

=item ret: no return value

=back





=head2 C<FETCH>

  $ret = $t->FETCH($key);

=over 4

=item arg1: C<$t> (C<L<APR::Table|docs::2.0::api::APR::Table>>)

=item arg2: C<$key> (string)

=item ret: C<$ret> (string)

=back




=head1 See Also

L<mod_perl 2.0 documentation|docs::2.0::index>.




=head1 Copyright

mod_perl 2.0 and its core modules are copyrighted under
The Apache Software License, Version 1.1.




=head1 Authors

L<The mod_perl development team and numerous
contributors|about::contributors::people>.

=cut

