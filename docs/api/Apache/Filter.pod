=head1 NAME

Apache::Filter - Perl API for Apache 2.0 Filtering




=head1 Synopsis

  use Apache::Filter ();

META: to be completed




=head1 Description


C<Apache::Filter> provides the Perl API for Apache 2.0 filtering
framework.

Make sure to read C<the Filtering
tutorial|docs::2.0::user::handlers::filters>.




=head1 Common Filter API

The following methods can be called from any filter handler:




=head2 C<c>

The current connection object can be retrieved from a connection or a
request filter with:

  $c = $f->c;

=over 4

=item arg1: C<$f> (C<L<Apache::Filter|docs::2.0::api::Apache::Filter>>)

=item ret: C<$c> (C<L<Apache::Connection|docs::2.0::api::Apache::Connection>>)

=back




=head2 C<ctx>

Get and set the filter context data.

  $ctx = $f->ctx;
  $f->ctx($ctx);

=over 4

=item arg1: C<$f> (C<L<Apache::Filter|docs::2.0::api::Apache::Filter>>)

=item opt arg2: C<$ctx> (scalar)

Could be any perl SCALAR.

=item ret: C<$ctx> (scalar)

Could be any perl SCALAR.

=back

A filter context is created before the filter is called for the first
time and it's destroyed at the end of the request. The context is
preserved between filter invocations of the same request. So if a
filter needs to store some data between invocations it should use the
filter context for that.  The filter context is initialized with the
C<undef> value.

The C<ctx> method accepts a single SCALAR argument. Therefore if you
want to store any other perl datastructure you should use a reference
to it.

For example you can store a hash reference:

  $f->ctx({ foo => 'bar' });

and then access it:

  $foo = $f->ctx->{foo};

if you access the context more than once it's more efficient to copy
it's value before using it:

  my $ctx = $f->ctx;
  $foo = $ctx->{foo};

to avoid redundant method calls. As of this writing C<$ctx> is not a
tied variable, so if you modify it need to store it at the end:

  $f->ctx($ctx);

META: later we might make it a TIEd-variable interface, so it'll be
stored automatically.

Besides its usage to store data between filter invocations, this
method is also useful when as a flag. For example here is how to
ensure that something happens only once during the filter's life:

      unless ($f->ctx) {
          do_something_once();
          $f->ctx(1);
      }




=head2 C<frec>

Get/set the C<L<Apache::FilterRec|docs::2.0::api::Apache::FilterRec>>
(filter record) object.

  my $frec = $f->frec();
  $f->frec($frec);

=over 4

=item arg1: C<$f> (C<L<Apache::Filter|docs::2.0::api::Apache::Filter>>)

=item opt arg2: C<$frec> (C<L<Apache::FilterRec|docs::2.0::api::Apache::FilterRec>>)

=item opt ret: C<$frec> (C<L<Apache::FilterRec|docs::2.0::api::Apache::FilterRec>>)

=back





=head2 C<next>

Returns the C<Apache::Filter> object of the next filter in chain.

  $next_f = $f->next;

=over 4

=item arg1: C<$f> (C<L<Apache::Filter|docs::2.0::api::Apache::Filter>>)

=item ret: C<$next_f> (C<L<Apache::Filter|docs::2.0::api::Apache::Filter>>)

=back


Since Apache inserts several core filters at the end of each chain,
normally this method always returns an object. However if it's not a
mod_perl filter handler, you can call only the following methods on
it: C<L<get_brigade|/C_get_brigade_>>,
C<L<pass_brigade|/C_pass_brigade_>>, C<L<c|/C_c_>>, C<L<r|/C_r_>>,
C<L<frec|/C_frec_>> and C<L<next|/C_next_>>. If you call other methods
the behavior is undefined.

META: I doubt anybody will ever need to mess with other filters, from
within a mod_perl filter. but if the need arises it's easy to tell a
mod_perl filter from non-mod_perl one by calling
C<$f-E<gt>frec-E<gt>name> (it'll return one of the following four
names: I<modperl_request_output>, I<modperl_request_input>,
I<modperl_connection_output> or I<modperl_connection_input>).





=head2 C<r>

Inside an HTTP request filter retrieve the current request object:

  $r = $f->r;

=over 4

=item arg1: C<$f> (C<L<Apache::Filter|docs::2.0::api::Apache::Filter>>)

=item ret: C<$r> (C<L<Apache::RequestRec|docs::2.0::api::Apache::RequestRec>>)

=back

If a sub-request adds filters, then the sub-request is the request
associated with the filter.





=head2 C<remove>

Remove the current filter from the filter chain (for the current
request or connection).

  $f->remove;

=over 4

=item arg1: C<$f> (C<L<Apache::Filter|docs::2.0::api::Apache::Filter>>)

=item ret: no return value

=item since: 1.99_10

=back

Notice that you should either complete the current filter invocation
normally (by calling C<L<get_brigade|/C_get_brigade_>> or
C<L<pass_brigade|/C_pass_brigade_>> depending on the filter kind) or
if nothing was done, return C<Apache::DECLINED> and mod_perl will take
care of passing the current bucket brigade through unmodified to the
next filter in chain.

Note: calling remove() on the very top connection filter doesn't
affect the filter chain due to a bug in Apache 2.0 (which may be fixed
in 2.1). So don't use it with connection filters, till it gets fixed
in Apache and then make sure to require the minimum Apache version if
you rely on.

Remember that if the connection is
C<L<$c-E<gt>keepalive|docs::2.0::api::Apache::Connection/C_keepalive_>>)
and the connection filter is removed, it won't be added untill the
connection is closed. Which may happen after many HTTP requests. You
may want to keep the filter in place and pass the data through
unmodified, by returning C<Apache::DECLINED>. If you need to reset the
whole or parts of the filter context between requests, use the
L<technique based on C<$c-E<gt>keepalives> counting|docs::2.0::user::handler::filters>.



=head1 Bucket Brigade Filter API

The following methods can be called from any filter, directly
manipulating bucket brigades:





=head2 C<fflush>

Flush the C<$bb> brigade down the filter stack.

  $ret = $f->fflush($bb);

=over 4

=item arg1: C<$f> (C<L<Apache::Filter|docs::2.0::api::Apache::Filter>>)

The current filter

=item arg2: C<$bb> (C<L<Apache::Filter|docs::2.0::api::Apache::Filter>>)

The brigade to flush

=item ret: XXX

=back




=head2 C<get_brigade>

This is a method to use in bucket brigade input filters. It acquires a
bucket brigade from the upstream input filter.

  $ret = $next_f->get_brigade($bb, $mode, $block, $readbytes);

=over 4

=item arg1: C<$next_f> (C<L<Apache::Filter|docs::2.0::api::Apache::Filter>>)

The next filter in the chain

=item arg2: C<$bb> (C<L<APR::Brigade|docs::2.0::api::APR::Brigade>>)

The original brigade passed to get_brigade() must be empty.  On return
it gets populated with the next bucket brigade, or nothing if there is
no more data to read.

=item arg3: C<$mode> (integer)

The way in which the data should be read

=item arg4: C<$block> (integer)

How the operations should be performed APR::BLOCK_READ,
APR::NONBLOCK_READ

=item arg5: C<$readbytes> (integer)

How many bytes to read from the next filter.

=item ret: C<$ret> (integer)

It returns C<APR::SUCCESS> on success, otherwise a failure code, in
which case it should be returned to the caller.

If the bottom-most filter doesn't read from the network, then
Apache::NOBODY_READ is returned (META: need to add this constant).

=back

For example:

  sub filter {
      my($f, $bb, $mode, $block, $readbytes) = @_;
      
      my $rv = $f->next->get_brigade($bb, $mode, $block, $readbytes);
      return $rv unless $rv == APR::SUCCESS;
      
      # ... process $bb
      
      return Apache::OK;
  }

Normally arguments C<$mode>, C<$block>, C<$readbytes> are the same as
passed to the filter itself.

It returns C<APR::SUCCESS> on success, otherwise a failure code, in
which case it should be returned to the caller.




=head2 C<pass_brigade>

This is a method to use in bucket brigade output filters.  It passes
the current bucket brigade to the downstream output filter.

  $ret = $next_f->pass_brigade($bb);

=over 4

=item arg1: C<$next_f> (C<L<Apache::Filter|docs::2.0::api::Apache::Filter>>)

The next filter in the chain

=item arg2: C<$bb> (C<L<APR::Brigade|docs::2.0::api::APR::Brigade>>)

The current bucket brigade

=item ret: C<$ret> (integer)

It returns C<APR::SUCCESS> on success, otherwise a failure code, in
which case it should be returned to the caller.

If the bottom-most filter doesn't write to the network, then
Apache::NOBODY_WROTE is returned (META: need to add this constant).

=back

The caller relinquishes ownership of the brigade (i.e. it may get
destroyed/overwritten/etc by the callee).

For example:

  sub filter {
      my($f, $bb) = @_;
      
      # ... process $bb
      
      my $rv = $f->next->pass_brigade($bb);
      return $rv unless $rv == APR::SUCCESS;
      
      # process $bb
      return Apache::OK;
  }








=head1 Streaming Filter API

The following methods can be called from any filter, which uses the
simplified streaming functionality:

=head2 C<seen_eos>

This methods returns a true value when the EOS bucket is seen by the
C<L<read|/C_read_>> method.

  $ret = $f->seen_eos;

=over 4

=item arg1: C<$f> (C<L<Apache::Filter|docs::2.0::api::Apache::Filter>>)

The filter to remove

=item ret: C<$ret> (integer)

a true value if seen, otherwise a false value

=back

This method only works in streaming filters which
exhaustively C<L<$f-E<gt>read|/C_read_>> all the incoming data in a
while loop, like so:

      while ($f->read(my $buffer, $read_len)) {
          # do something with $buffer
      }
      if ($f->seen_eos) {
          # do something
      }

This method is useful when a streaming filter wants to append
something to the very end of data, or do something at the end of the
last filter invocation. After the EOS bucket is read, the filter
should expect not to be invoked again.

If an input streaming filter doesn't consume all data in the bucket
brigade (or even in several bucket brigades), it has to generate the
EOS event by itself. So when the filter is done it has to set the EOS
flag:

  $f->seen_eos(1);

when the filter handler returns, internally mod_perl will take care of
creating and sending the EOS bucket to the upstream input filter.

A similar logic may apply for output filters.

In most other cases you shouldn't set this flag.  When this flag is
prematurely set (before the real EOS bucket has arrived) in the
current filter invocation, instead of invoking the filter again,
mod_perl will create and send the EOS bucket to the next filter,
ignoring any other bucket brigades that may have left to consume. As
mentioned earlier this special behavior is useful in writing special
tests that test abnormal situations.



=head2 C<read>

Read data from the filter

  $ret = $f->read(my $buffer, $read_len);

=over 4

=item arg1: C<$f> (C<L<Apache::Filter|docs::2.0::api::Apache::Filter>>)

=item arg2: C<$buffer> (scalar)

=item arg3: C<$read_len> (integer)

=item ret: C<$ret> (number)

=back

Reads at most C<$read_len> characters into C<$buffer>. It returns a
true value as long as it had something to read, or a false value
otherwise.

This is a streaming filter method, which acquires a single bucket
brigade behind the scenes and reads data from all its
buckets. Therefore it can only read from one bucket brigade per filter
invocation.

If the EOS bucket is read, the C<L<seen_eos|/C_seen_eos_>> method will
return a true value.



=head2 C<fputs>

META: Autogenerated - needs to be reviewed/completed

  $ret = $f->fputs($bb, $str);

=over 4

=item arg1: C<$f> (C<L<Apache::Filter|docs::2.0::api::Apache::Filter>>)

=item arg2: C<$bb> (C<L<APR::Brigade|docs::2.0::api::APR::Brigade>>)

=item arg3: C<$str> (string)

=item ret: C<$ret> (integer)

=back



=head2 C<print>

Send the contents of C<$buffer> to the next filter in chain (via
internal buffer).

  $f->print($buffer);

=over 4

=item arg1: C<$f> (C<L<Apache::Filter|docs::2.0::api::Apache::Filter>>)

=item arg2: C<$buffer> (scalar)

=item ret: XXX

=back

This method should be used only in streaming filters.






=head1 Other Filter-related API

Other methods which affect filters, but called on
non-C<Apache::Filter> objects:



=head2 C<add_input_filter>

Add C<&callback> filter handler to input request filter chain.

  $r->add_input_filter(\&callback);

Add C<&callback> filter handler to input connection filter chain.

  $c->add_input_filter(\&callback);

=over 4

=item arg1: C<$c> (C<L<Apache::Connection|docs::2.0::api::Apache::Connection>>) or C<$r> (C<L<Apache::RequestRec|docs::2.0::api::Apache::RequestRec>>)

=item arg2: C<&callback> (CODE ref)

=item ret: XXX

=back

[META: It seems that you can't add a filter when another filter is
called. I've tried to add an output connection filter from the input
connection filter when it was called for the first time. It didn't
have any affect for the first request (over keepalive connection). The
only way I succeeded to do that is from that input connection filter's
filter_init handler.
In fact it does work if there is any filter additional filter of the
same kind configured from httpd.conf or via filter_init. It looks like
there is a bug in httpd, where it doesn't prepare the chain of 3rd
party filter if none were inserted before the first filter was called.]




=head2 C<add_output_filter>

Add C<&callback> filter handler to output request filter chain.

  $r->add_output_filter(\&callback);

Add C<&callback> filter handler to output connection filter chain.

  $c->add_output_filter(\&callback);

=over 4

=item arg1: C<$c> (C<L<Apache::Connection|docs::2.0::api::Apache::Connection>>) or C<$r> (C<L<Apache::RequestRec|docs::2.0::api::Apache::RequestRec>>)

=item arg2: C<&callback> (CODE ref)

=item ret: XXX

=back





=head1 TIE Interface

C<Apache::Filter> also implements a tied interface, so you can work
with the C<$f> object as a hash reference.

META: complete



=head2 C<TIEHANDLE>

META: Autogenerated - needs to be reviewed/completed

  $ret = TIEHANDLE($stashsv, $sv);

=over 4

=item arg1: C<$stashsv> (scalar)

=item arg2: C<$sv> (scalar)

=item ret: C<$ret> (scalar)

=back





=head2 C<PRINT>

META: Autogenerated - needs to be reviewed/completed

  $ret = PRINT(...);

=over 4

=item arg1: C<...> (XXX)

=item ret: C<$ret> (integer)

=back





=head1 Filter Handler Attributes

Packages using filter attributes have to subclass C<Apache::Filter>:

  package MyApache::FilterCool;
  use base qw(Apache::Filter);

Attributes are parsed during the code compilation, by the function
C<MODIFY_CODE_ATTRIBUTES>, inherited from the C<Apache::Filter>
package.




=head2 C<FilterRequestHandler>

The C<FilterRequestHandler> attribute tells mod_perl to insert the
filter into an HTTP request filter chain. 

For example, to configure an output request filter handler, use the
C<FilterRequestHandler> attribute in the handler subroutine's
declaration:

  package MyApache::FilterOutputReq;
  sub handler : FilterRequestHandler { ... }

and add the configuration entry:

  PerlOutputFilterHandler MyApache::FilterOutputReq

This is the default mode. So if you are writing an HTTP request
filter, you don't have to specify this attribute.

The section L<HTTP Request vs. Connection
Filters|docs::2.0::user::handlers::filters/HTTP_Request_vs__Connection_Filters>
delves into more details.




=head2 C<FilterConnectionHandler>

The C<FilterConnectionHandler> attribute tells mod_perl to insert this
filter into a connection filter chain.

For example, to configure an output connection filter handler, use the
C<FilterConnectionHandler> attribute in the handler subroutine's
declaration:

  package MyApache::FilterOutputCon;
  sub handler : FilterConnectionHandler { ... }

and add the configuration entry:

  PerlOutputFilterHandler MyApache::FilterOutputCon

The section L<HTTP Request vs. Connection
Filters|docs::2.0::user::handlers::filters/HTTP_Request_vs__Connection_Filters>
delves into more details.




=head2 C<FilterInitHandler>

The attribute C<FilterInitHandler> marks the function suitable to be
used as a filter initialization callback, which is called immediately
after a filter is inserted to the filter chain and before it's
actually called.

  sub init : FilterInitHandler {
      my $f = shift;
      #...
      return Apache::OK;
  }

In order to hook this filter callback, the real filter has to assign
this callback using the
C<L<FilterHasInitHandler|/C_FilterHasInitHandler_>> which accepts a
reference to the callback function.

For further discussion and examples refer to the L<Filter
Initialization
Phase|docs::2.0::user::handlers::filters/Filter_Initialization_Phase>
tutorial section.




=head2 C<FilterHasInitHandler>

If a filter wants to run an initialization callback it can register
such using the C<FilterHasInitHandler> attribute. Similar to
C<push_handlers> the callback reference is expected, rather than a
callback name. The used callback function has to have the
C<L<FilterInitHandler|/C_FilterInitHandler_>> attribute. For example:

  package MyApache::FilterBar;
  use base qw(Apache::Filter);
  sub init   : FilterInitHandler { ... }
  sub filter : FilterRequestHandler FilterHasInitHandler(\&init) {
      my ($f, $bb) = @_;
      # ...
      return Apache::OK;
  }

For further discussion and examples refer to the L<Filter
Initialization
Phase|docs::2.0::user::handlers::filters/Filter_Initialization_Phase>
tutorial section.




=head1 Configuration

mod_perl 2.0 filters configuration is explained in the L<filter
handlers
tutorial|docs::2.0::user::handlers::filters/mod_perl_Filters_Declaration_and_Configuration>.



=head2 C<PerlInputFilterHandler>

See
C<L<PerlInputFilterHandler|docs::2.0::user::handlers::filters/C_PerlInputFilterHandler_>>.



=head2 C<PerlOutputFilterHandler>

See
C<L<PerlOutputFilterHandler|docs::2.0::user::handlers::filters/C_PerlOutputFilterHandler_>>.



=head2 C<PerlSetInputFilter>

See
C<L<PerlSetInputFilter|docs::2.0::user::handlers::filters/C_PerlSetInputFilter_>>.



=head2 C<PerlSetOutputFilter>


See
C<L<PerlSetInputFilter|docs::2.0::user::handlers::filters/C_PerlSetInputFilter_>>.


=head1 See Also

L<mod_perl 2.0 documentation|docs::2.0::index>.




=head1 Copyright

mod_perl 2.0 and its core modules are copyrighted under
The Apache Software License, Version 1.1.




=head1 Authors

L<The mod_perl development team and numerous
contributors|about::contributors::people>.

=cut

